{
    "candidates": [
        {
            "content": {
                "role": "model",
                "parts": [
                    {
                        "text": "Of course. As a cloud architect, I will provide a robust and production-ready Terraform configuration for deploying a web application on Google Cloud.\n\n### Architecture Overview\n\nThis solution will deploy the following resources:\n\n1.  **VPC Network**: A custom Virtual Private Cloud (VPC) to provide a secure and isolated network for our resources, which is a best practice over using the `default` network.\n2.  **Firewall Rules**: Essential rules to allow health checks and traffic from the load balancer to our backend instances. A rule to allow SSH for management is also included (but should be restricted in a real production environment).\n3.  **Instance Templates**: Two distinct templates, one for each backend API. These templates define the configuration of the virtual machines, including machine type and a startup script to simulate the API application.\n4.  **Managed Instance Groups (MIGs)**: Two MIGs, one for each API, built from the instance templates. MIGs provide auto-healing, auto-scaling, and rolling update capabilities.\n5.  **Global External HTTP Load Balancer**: A highly available, global load balancer to distribute traffic.\n    *   **Health Check**: Monitors the health of instances in our MIGs.\n    *   **Backend Services**: Two backend services, one for each MIG.\n    *   **URL Map**: Routes incoming requests based on the URL path (`/api1` or `/api2`) to the appropriate backend service.\n    *   **IP Address, Target Proxy, and Forwarding Rule**: The public-facing components that tie everything together.\n\nThis architecture is highly scalable and resilient, forming a solid foundation for any web service.\n\nHere is the complete Terraform code.\n\n[CODE]\n```terraform\n# ------------------------------------------------------------------------------\n# Provider Configuration\n# ------------------------------------------------------------------------------\nterraform {\n  required_providers {\n    google = {\n      source  = \"hashicorp/google\"\n      version = \">= 4.50.0\"\n    }\n  }\n}\n\nprovider \"google\" {\n  project = var.project_id\n  region  = var.region\n}\n\n# ------------------------------------------------------------------------------\n# Variables\n# ------------------------------------------------------------------------------\nvariable \"project_id\" {\n  description = \"The Google Cloud project ID.\"\n  type        = string\n}\n\nvariable \"region\" {\n  description = \"The GCP region to deploy resources into.\"\n  type        = string\n  default     = \"us-central1\"\n}\n\nvariable \"zone\" {\n  description = \"The GCP zone for the Managed Instance Groups.\"\n  type        = string\n  default     = \"us-central1-a\"\n}\n\nvariable \"name_prefix\" {\n  description = \"A prefix to be used for all created resources.\"\n  type        = string\n  default     = \"webapp-demo\"\n}\n\n# ------------------------------------------------------------------------------\n# Network Configuration\n# ------------------------------------------------------------------------------\nresource \"google_compute_network\" \"main\" {\n  name                    = \"${var.name_prefix}-vpc\"\n  auto_create_subnetworks = false\n}\n\nresource \"google_compute_subnetwork\" \"main\" {\n  name          = \"${var.name_prefix}-subnet\"\n  ip_cidr_range = \"10.10.0.0/24\"\n  network       = google_compute_network.main.id\n  region        = var.region\n}\n\n# ------------------------------------------------------------------------------\n# Firewall Rules\n# ------------------------------------------------------------------------------\nresource \"google_compute_firewall\" \"allow_lb_health_check\" {\n  name    = \"${var.name_prefix}-allow-lb-hc\"\n  network = google_compute_network.main.name\n  allow {\n    protocol = \"tcp\"\n    ports    = [\"80\"]\n  }\n  # These are the official IP ranges for Google Cloud Load Balancers and Health Checks.\n  source_ranges = [\"130.211.0.0/22\", \"35.191.0.0/16\"]\n  target_tags   = [\"http-server\"]\n}\n\nresource \"google_compute_firewall\" \"allow_ssh\" {\n  name    = \"${var.name_prefix}-allow-ssh\"\n  network = google_compute_network.main.name\n  allow {\n    protocol = \"tcp\"\n    ports    = [\"22\"]\n  }\n  # WARNING: This allows SSH from any IP. For production, restrict this to your IP range.\n  source_ranges = [\"0.0.0.0/0\"]\n  target_tags   = [\"ssh-access\"]\n}\n\n# ------------------------------------------------------------------------------\n# Backend API 1 Configuration\n# ------------------------------------------------------------------------------\nresource \"google_compute_instance_template\" \"api1\" {\n  name_prefix  = \"${var.name_prefix}-api1-template-\"\n  machine_type = \"e2-micro\"\n  tags         = [\"http-server\", \"ssh-access\"]\n\n  disk {\n    source_image = \"debian-cloud/debian-11\"\n    auto_delete  = true\n    boot         = true\n  }\n\n  network_interface {\n    network    = google_compute_network.main.id\n    subnetwork = google_compute_subnetwork.main.id\n  }\n\n  # This startup script simulates a simple web server for API 1\n  metadata_startup_script = <<-EOT\n    #!/bin/bash\n    apt-get update\n    apt-get install -yq python3-pip\n    pip3 install flask\n    cat <<EOF > /home/app.py\n    from flask import Flask\n    app = Flask(__name__)\n    @app.route('/')\n    def hello():\n        return 'Hello from Backend API 1!'\n    @app.route('/api1')\n    def api1_hello():\n        return 'Response from API 1 endpoint!'\n    if __name__ == '__main__':\n        app.run(host='0.0.0.0', port=80)\n    EOF\n    python3 /home/app.py &\n  EOT\n}\n\nresource \"google_compute_instance_group_manager\" \"api1\" {\n  name               = \"${var.name_prefix}-mig-api1\"\n  base_instance_name = \"${var.name_prefix}-vm-api1\"\n  zone               = var.zone\n  target_size        = 2\n\n  version {\n    instance_template = google_compute_instance_template.api1.id\n  }\n\n  auto_healing_policies {\n    health_check      = google_compute_health_check.http.id\n    initial_delay_sec = 60\n  }\n}\n\n# ------------------------------------------------------------------------------\n# Backend API 2 Configuration\n# ------------------------------------------------------------------------------\nresource \"google_compute_instance_template\" \"api2\" {\n  name_prefix  = \"${var.name_prefix}-api2-template-\"\n  machine_type = \"e2-micro\"\n  tags         = [\"http-server\", \"ssh-access\"]\n\n  disk {\n    source_image = \"debian-cloud/debian-11\"\n    auto_delete  = true\n    boot         = true\n  }\n\n  network_interface {\n    network    = google_compute_network.main.id\n    subnetwork = google_compute_subnetwork.main.id\n  }\n\n  # This startup script simulates a simple web server for API 2\n  metadata_startup_script = <<-EOT\n    #!/bin/bash\n    apt-get update\n    apt-get install -yq python3-pip\n    pip3 install flask\n    cat <<EOF > /home/app.py\n    from flask import Flask\n    app = Flask(__name__)\n    @app.route('/')\n    def hello():\n        return 'Hello from Backend API 2!'\n    @app.route('/api2')\n    def api2_hello():\n        return 'Response from API 2 endpoint!'\n    if __name__ == '__main__':\n        app.run(host='0.0.0.0', port=80)\n    EOF\n    python3 /home/app.py &\n  EOT\n}\n\nresource \"google_compute_instance_group_manager\" \"api2\" {\n  name               = \"${var.name_prefix}-mig-api2\"\n  base_instance_name = \"${var.name_prefix}-vm-api2\"\n  zone               = var.zone\n  target_size        = 2\n\n  version {\n    instance_template = google_compute_instance_template.api2.id\n  }\n\n  auto_healing_policies {\n    health_check      = google_compute_health_check.http.id\n    initial_delay_sec = 60\n  }\n}\n\n# ------------------------------------------------------------------------------\n# Load Balancer Configuration\n# ------------------------------------------------------------------------------\nresource \"google_compute_global_address\" \"main\" {\n  name = \"${var.name_prefix}-lb-ip\"\n}\n\nresource \"google_compute_health_check\" \"http\" {\n  name                = \"${var.name_prefix}-http-health-check\"\n  check_interval_sec  = 5\n  timeout_sec         = 5\n  healthy_threshold   = 2\n  unhealthy_threshold = 2\n\n  http_check {\n    port         = 80\n    request_path = \"/\"\n  }\n}\n\nresource \"google_compute_backend_service\" \"api1\" {\n  name        = \"${var.name_prefix}-backend-api1\"\n  port_name   = \"http\"\n  protocol    = \"HTTP\"\n  timeout_sec = 10\n  health_checks = [\n    google_compute_health_check.http.id\n  ]\n  backend {\n    group = google_compute_instance_group_manager.api1.instance_group\n  }\n}\n\nresource \"google_compute_backend_service\" \"api2\" {\n  name        = \"${var.name_prefix}-backend-api2\"\n  port_name   = \"http\"\n  protocol    = \"HTTP\"\n  timeout_sec = 10\n  health_checks = [\n    google_compute_health_check.http.id\n  ]\n  backend {\n    group = google_compute_instance_group_manager.api2.instance_group\n  }\n}\n\nresource \"google_compute_url_map\" \"main\" {\n  name            = \"${var.name_prefix}-url-map\"\n  default_service = google_compute_backend_service.api1.id\n\n  path_matcher {\n    name            = \"api-path-matcher\"\n    default_service = google_compute_backend_service.api1.id\n    path_rule {\n      paths   = [\"/api1\", \"/api1/*\"]\n      service = google_compute_backend_service.api1.id\n    }\n    path_rule {\n      paths   = [\"/api2\", \"/api2/*\"]\n      service = google_compute_backend_service.api2.id\n    }\n  }\n}\n\nresource \"google_compute_target_http_proxy\" \"main\" {\n  name    = \"${var.name_prefix}-http-proxy\"\n  url_map = google_compute_url_map.main.id\n}\n\nresource \"google_compute_global_forwarding_rule\" \"main\" {\n  name       = \"${var.name_prefix}-forwarding-rule\"\n  target     = google_compute_target_http_proxy.main.id\n  ip_address = google_compute_global_address.main.address\n  port_range = \"80\"\n}\n\n# ------------------------------------------------------------------------------\n# Outputs\n# ------------------------------------------------------------------------------\noutput \"load_balancer_ip\" {\n  description = \"The public IP address of the load balancer.\"\n  value       = google_compute_global_address.main.address\n}\n```\n[CODE]\n\n### How to Use This Code\n\n1.  **Prerequisites**:\n    *   Install [Terraform](https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli).\n    *   Install and configure the [Google Cloud SDK](https://cloud.google.com/sdk/docs/install) (`gcloud`).\n    *   Authenticate with GCP: `gcloud auth application-default login`.\n    *   Enable the required APIs in your project:\n        ```bash\n        gcloud services enable compute.googleapis.com --project YOUR_PROJECT_ID\n        ```\n\n2.  **Deployment**:\n    *   Save the code above as `main.tf`.\n    *   Create a file named `terraform.tfvars` and add your project ID:\n        ```tfvars\n        project_id = \"your-gcp-project-id\"\n        ```\n    *   Initialize Terraform:\n        ```bash\n        terraform init\n        ```\n    *   Review the plan:\n        ```bash\n        terraform plan -var-file=\"terraform.tfvars\"\n        ```\n    *   Apply the configuration:\n        ```bash\n        terraform apply -var-file=\"terraform.tfvars\"\n        ```\n\n3.  **Testing**:\n    *   After the `apply` command completes, Terraform will output the public IP address of the load balancer.\n    *   It may take a few minutes for the instances to boot up and the load balancer to become fully operational and pass health checks.\n    *   Test the different API endpoints in your browser or using `curl`:\n        *   `curl http://<LOAD_BALANCER_IP>/` or `curl http://<LOAD_BALANCER_IP>/api1` should return a response from **API 1**.\n        *   `curl http://<LOAD_BALANCER_IP>/api2` should return a response from **API 2**.\n\n### Next Steps and Best Practices\n\n*   **HTTPS**: This example uses an HTTP load balancer for simplicity. For production, you should use an HTTPS load balancer (`google_compute_target_https_proxy`) with a Google-managed SSL certificate (`google_compute_managed_ssl_certificate`), which requires a registered domain.\n*   **Containerization**: Instead of using startup scripts, package your applications as Docker containers and deploy them using Container-Optimized OS on the instance templates or, for a more managed approach, use Google Kubernetes Engine (GKE) or Cloud Run.\n*   **CI/CD**: Integrate this Terraform code into a CI/CD pipeline (like GitHub Actions or Cloud Build) to automate the deployment process.\n*   **Modularization**: For larger projects, split this code into multiple Terraform modules (e.g., a network module, a compute module, and a load balancer module) for better organization and reusability."
                    }
                ]
            },
            "finishReason": "STOP",
            "safetyRatings": [
                {
                    "category": "HARM_CATEGORY_HATE_SPEECH",
                    "probability": "NEGLIGIBLE",
                    "probabilityScore": 8.844878e-7,
                    "severity": "HARM_SEVERITY_NEGLIGIBLE",
                    "severityScore": 0.12210894
                },
                {
                    "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                    "probability": "NEGLIGIBLE",
                    "probabilityScore": 0.000026150936,
                    "severity": "HARM_SEVERITY_NEGLIGIBLE",
                    "severityScore": 0.015021808
                },
                {
                    "category": "HARM_CATEGORY_HARASSMENT",
                    "probability": "NEGLIGIBLE",
                    "probabilityScore": 0.0000012340388,
                    "severity": "HARM_SEVERITY_NEGLIGIBLE",
                    "severityScore": 0.11089388
                },
                {
                    "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                    "probability": "NEGLIGIBLE",
                    "probabilityScore": 7.680191e-8,
                    "severity": "HARM_SEVERITY_NEGLIGIBLE"
                }
            ],
            "avgLogprobs": -0.18827445825412648,
            "index": 0
        }
    ],
    "usageMetadata": {
        "promptTokenCount": 64,
        "candidatesTokenCount": 3370,
        "totalTokenCount": 5646,
        "trafficType": "ON_DEMAND",
        "promptTokensDetails": [
            {
                "modality": "TEXT",
                "tokenCount": 64
            }
        ],
        "candidatesTokensDetails": [
            {
                "modality": "TEXT",
                "tokenCount": 3370
            }
        ],
        "thoughtsTokenCount": 2212
    },
    "modelVersion": "gemini-2.5-pro",
    "createTime": "2025-06-30T14:10:52.417299Z",
    "responseId": "7JpiaJO8GY6CsbQP2p61sAE"
}